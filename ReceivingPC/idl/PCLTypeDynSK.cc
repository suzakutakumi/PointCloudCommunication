// This file is generated by omniidl (C++ backend) - omniORB_4_2. Do not edit.

#include "PCLType.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_2_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::PR_structMember _0RL_structmember_PCLType_mColor[] = {
  {"r", CORBA::TypeCode::PR_ushort_tc()},
  {"g", CORBA::TypeCode::PR_ushort_tc()},
  {"b", CORBA::TypeCode::PR_ushort_tc()}
};

#ifdef _0RL_tc_PCLType_mColor
#  undef _0RL_tc_PCLType_mColor
#endif
static CORBA::TypeCode_ptr _0RL_tc_PCLType_mColor = CORBA::TypeCode::PR_struct_tc("IDL:PCLType/Color:1.0", "Color", _0RL_structmember_PCLType_mColor, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace PCLType { 
  const ::CORBA::TypeCode_ptr _tc_Color = _0RL_tc_PCLType_mColor;
} 
#else
const ::CORBA::TypeCode_ptr PCLType::_tc_Color = _0RL_tc_PCLType_mColor;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mPoint3D[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()},
  {"z", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mPoint3D
#  undef _0RL_tc_RTC_mPoint3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPoint3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Point3D:1.0", "Point3D", _0RL_structmember_RTC_mPoint3D, 3, &_0RL_tcTrack);


static CORBA::PR_structMember _0RL_structmember_PCLType_mPointXYZRGB[] = {
  {"point", _0RL_tc_RTC_mPoint3D},
  {"colour", _0RL_tc_PCLType_mColor}
};

#ifdef _0RL_tc_PCLType_mPointXYZRGB
#  undef _0RL_tc_PCLType_mPointXYZRGB
#endif
static CORBA::TypeCode_ptr _0RL_tc_PCLType_mPointXYZRGB = CORBA::TypeCode::PR_struct_tc("IDL:PCLType/PointXYZRGB:1.0", "PointXYZRGB", _0RL_structmember_PCLType_mPointXYZRGB, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace PCLType { 
  const ::CORBA::TypeCode_ptr _tc_PointXYZRGB = _0RL_tc_PCLType_mPointXYZRGB;
} 
#else
const ::CORBA::TypeCode_ptr PCLType::_tc_PointXYZRGB = _0RL_tc_PCLType_mPointXYZRGB;
#endif














static CORBA::TypeCode_ptr _0RL_tc_PCLType_mPointXYZRGBList = CORBA::TypeCode::PR_alias_tc("IDL:PCLType/PointXYZRGBList:1.0", "PointXYZRGBList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_PCLType_mPointXYZRGB, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace PCLType { 
  const ::CORBA::TypeCode_ptr _tc_PointXYZRGBList = _0RL_tc_PCLType_mPointXYZRGBList;
} 
#else
const ::CORBA::TypeCode_ptr PCLType::_tc_PointXYZRGBList = _0RL_tc_PCLType_mPointXYZRGBList;
#endif

static CORBA::PR_structMember _0RL_structmember_RTC_mTime[] = {
  {"sec", CORBA::TypeCode::PR_ulong_tc()},
  {"nsec", CORBA::TypeCode::PR_ulong_tc()}
};

#ifdef _0RL_tc_RTC_mTime
#  undef _0RL_tc_RTC_mTime
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTime = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Time:1.0", "Time", _0RL_structmember_RTC_mTime, 2, &_0RL_tcTrack);




static CORBA::PR_structMember _0RL_structmember_PCLType_mPointCloud[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"pc", _0RL_tc_PCLType_mPointXYZRGBList},
  {"height", CORBA::TypeCode::PR_ulong_tc()},
  {"width", CORBA::TypeCode::PR_ulong_tc()},
  {"is_dense", CORBA::TypeCode::PR_boolean_tc()}
};

#ifdef _0RL_tc_PCLType_mPointCloud
#  undef _0RL_tc_PCLType_mPointCloud
#endif
static CORBA::TypeCode_ptr _0RL_tc_PCLType_mPointCloud = CORBA::TypeCode::PR_struct_tc("IDL:PCLType/PointCloud:1.0", "PointCloud", _0RL_structmember_PCLType_mPointCloud, 5, &_0RL_tcTrack);





#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace PCLType { 
  const ::CORBA::TypeCode_ptr _tc_PointCloud = _0RL_tc_PCLType_mPointCloud;
} 
#else
const ::CORBA::TypeCode_ptr PCLType::_tc_PointCloud = _0RL_tc_PCLType_mPointCloud;
#endif


static void _0RL_PCLType_mColor_marshal_fn(cdrStream& _s, void* _v)
{
  PCLType::Color* _p = (PCLType::Color*)_v;
  *_p >>= _s;
}
static void _0RL_PCLType_mColor_unmarshal_fn(cdrStream& _s, void*& _v)
{
  PCLType::Color* _p = new PCLType::Color;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_PCLType_mColor_destructor_fn(void* _v)
{
  PCLType::Color* _p = (PCLType::Color*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const PCLType::Color& _s)
{
  PCLType::Color* _p = new PCLType::Color(_s);
  _a.PR_insert(_0RL_tc_PCLType_mColor,
               _0RL_PCLType_mColor_marshal_fn,
               _0RL_PCLType_mColor_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, PCLType::Color* _sp)
{
  _a.PR_insert(_0RL_tc_PCLType_mColor,
               _0RL_PCLType_mColor_marshal_fn,
               _0RL_PCLType_mColor_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, PCLType::Color*& _sp)
{
  return _a >>= (const PCLType::Color*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const PCLType::Color*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_PCLType_mColor,
                    _0RL_PCLType_mColor_unmarshal_fn,
                    _0RL_PCLType_mColor_marshal_fn,
                    _0RL_PCLType_mColor_destructor_fn,
                    _v)) {
    _sp = (const PCLType::Color*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_PCLType_mPointXYZRGB_marshal_fn(cdrStream& _s, void* _v)
{
  PCLType::PointXYZRGB* _p = (PCLType::PointXYZRGB*)_v;
  *_p >>= _s;
}
static void _0RL_PCLType_mPointXYZRGB_unmarshal_fn(cdrStream& _s, void*& _v)
{
  PCLType::PointXYZRGB* _p = new PCLType::PointXYZRGB;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_PCLType_mPointXYZRGB_destructor_fn(void* _v)
{
  PCLType::PointXYZRGB* _p = (PCLType::PointXYZRGB*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const PCLType::PointXYZRGB& _s)
{
  PCLType::PointXYZRGB* _p = new PCLType::PointXYZRGB(_s);
  _a.PR_insert(_0RL_tc_PCLType_mPointXYZRGB,
               _0RL_PCLType_mPointXYZRGB_marshal_fn,
               _0RL_PCLType_mPointXYZRGB_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, PCLType::PointXYZRGB* _sp)
{
  _a.PR_insert(_0RL_tc_PCLType_mPointXYZRGB,
               _0RL_PCLType_mPointXYZRGB_marshal_fn,
               _0RL_PCLType_mPointXYZRGB_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, PCLType::PointXYZRGB*& _sp)
{
  return _a >>= (const PCLType::PointXYZRGB*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const PCLType::PointXYZRGB*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_PCLType_mPointXYZRGB,
                    _0RL_PCLType_mPointXYZRGB_unmarshal_fn,
                    _0RL_PCLType_mPointXYZRGB_marshal_fn,
                    _0RL_PCLType_mPointXYZRGB_destructor_fn,
                    _v)) {
    _sp = (const PCLType::PointXYZRGB*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_PCLType_mPointXYZRGBList_marshal_fn(cdrStream& _s, void* _v)
{
  PCLType::PointXYZRGBList* _p = (PCLType::PointXYZRGBList*)_v;
  *_p >>= _s;
}
static void _0RL_PCLType_mPointXYZRGBList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  PCLType::PointXYZRGBList* _p = new PCLType::PointXYZRGBList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_PCLType_mPointXYZRGBList_destructor_fn(void* _v)
{
  PCLType::PointXYZRGBList* _p = (PCLType::PointXYZRGBList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const PCLType::PointXYZRGBList& _s)
{
  PCLType::PointXYZRGBList* _p = new PCLType::PointXYZRGBList(_s);
  _a.PR_insert(_0RL_tc_PCLType_mPointXYZRGBList,
               _0RL_PCLType_mPointXYZRGBList_marshal_fn,
               _0RL_PCLType_mPointXYZRGBList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, PCLType::PointXYZRGBList* _sp)
{
  _a.PR_insert(_0RL_tc_PCLType_mPointXYZRGBList,
               _0RL_PCLType_mPointXYZRGBList_marshal_fn,
               _0RL_PCLType_mPointXYZRGBList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, PCLType::PointXYZRGBList*& _sp)
{
  return _a >>= (const PCLType::PointXYZRGBList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const PCLType::PointXYZRGBList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_PCLType_mPointXYZRGBList,
                    _0RL_PCLType_mPointXYZRGBList_unmarshal_fn,
                    _0RL_PCLType_mPointXYZRGBList_marshal_fn,
                    _0RL_PCLType_mPointXYZRGBList_destructor_fn,
                    _v)) {
    _sp = (const PCLType::PointXYZRGBList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_PCLType_mPointCloud_marshal_fn(cdrStream& _s, void* _v)
{
  PCLType::PointCloud* _p = (PCLType::PointCloud*)_v;
  *_p >>= _s;
}
static void _0RL_PCLType_mPointCloud_unmarshal_fn(cdrStream& _s, void*& _v)
{
  PCLType::PointCloud* _p = new PCLType::PointCloud;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_PCLType_mPointCloud_destructor_fn(void* _v)
{
  PCLType::PointCloud* _p = (PCLType::PointCloud*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const PCLType::PointCloud& _s)
{
  PCLType::PointCloud* _p = new PCLType::PointCloud(_s);
  _a.PR_insert(_0RL_tc_PCLType_mPointCloud,
               _0RL_PCLType_mPointCloud_marshal_fn,
               _0RL_PCLType_mPointCloud_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, PCLType::PointCloud* _sp)
{
  _a.PR_insert(_0RL_tc_PCLType_mPointCloud,
               _0RL_PCLType_mPointCloud_marshal_fn,
               _0RL_PCLType_mPointCloud_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, PCLType::PointCloud*& _sp)
{
  return _a >>= (const PCLType::PointCloud*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const PCLType::PointCloud*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_PCLType_mPointCloud,
                    _0RL_PCLType_mPointCloud_unmarshal_fn,
                    _0RL_PCLType_mPointCloud_marshal_fn,
                    _0RL_PCLType_mPointCloud_destructor_fn,
                    _v)) {
    _sp = (const PCLType::PointCloud*)_v;
    return 1;
  }
  return 0;
}

